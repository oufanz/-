/*
!标签：浮点数二分
!题目：
https://codefun2000.com/p/P1047
塔子哥住的小区前面有一条公路，在公路上有一排n 个居民楼，每个居民楼都有一个高度，第i 个居民楼的高度为ai，相邻居民楼都相隔100 米，塔子哥最近回家的时候经常没有路灯，然后经常迷路，现在塔子哥想在想要是公路左右两边各设计一座灯塔，这样灯塔就可以把所有地方都照亮，塔子哥回家路上就不会迷路了，现在塔子哥想知道灯塔至少得有多高。
为了简化问题，公路可看做一条直线， 居民楼和灯塔可看做立在公路旁边的一条竖线，左边的灯塔距离最左边的居民楼和右边灯塔距离最右边的居民楼也都是100 米。居民楼会挡住灯光，如果从最左边的居民楼到最右边的居民楼中间的点都要至少要被一座灯塔照亮， 那么两座灯塔高度之和最少是多少。
!题解：
枚举左边的灯塔的高度，二分得到右边的灯塔最低是多少，并更新最小值。
二分中的check用相似三角形算出每两个居民楼之间的两个灯塔没有照射到的部分是否超过了100m
*/
#include <bits/stdc++.h>
using namespace std;
int a[105];
int n;
int main()
{
    cin >> n;
    int mx = 0;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        mx = max(mx, a[i]);
    }
    double ans = 1e9;
    for (double x = mx; x <= 1e4; x += 0.5)
    {		//枚举左边的灯塔高度
        double L = mx, R = 2e5, mid;		//二分右边的灯塔高度
        for (int i = 1; i <= 30; i++)
        {		//浮点数二分指定次数，此时误差在2e5/(2^30)以内
            mid = (L + R) / 2;
            bool ok = true;
            for (int j = 1; j < n; j++)
            {			//依次判断每两个居民楼之间的间隔是否都照射到
                double t = (a[j] * j * 100) / (x - a[j]);		//计算左边的灯塔没照射到的部分
                t += (a[j + 1] * (n - j) * 100) / (mid - a[j + 1]);		//右边的
                if (t > 100)
                {//如果加起来超过100，说明有阴影部分
                    ok = false;
                    break;
                }
            }
            if (ok)
            {		//如果当前灯塔mid可以，说明最低的灯塔在[L,mid]的部分，将R置为mid
                R = mid;
            }
            else
            {		//反之是[mid,R]，将L置为mid
                L = mid;
            }
        }
        ans = min(ans, x + mid);		//最后用x+mid更新答案
    }
    cout << int(ans + 0.5);		//+0.5再舍去小数位，即四舍五入
}
